gitdatamodel(7)
===============

NAME
----
gitdatamodel - Git's core data model

DESCRIPTION
-----------

It's not necessary to understand Git's data model to use Git, but it's
very helpful when reading Git's documentation so that you know what it
means when the documentation says "object" "reference" or "index".

Git's core operations use 4 kinds of data:

1. <<objects,Objects>>: commits, trees, blobs, and tag objects
2. <<references,References>>: branches, tags,
   remote-tracking branches, etc
3. <<index,The index>>, also known as the staging area
4. <<reflogs,Reflogs>>

[[objects]]
OBJECTS
-------

Commits, trees, blobs, and tag objects are all stored in Git's object database.
Every object has:

1. an *ID*, which is the SHA-1 hash of its contents.
  It's fast to look up a Git object using its ID.
  The ID is usually represented in hexadecimal, like
  `1b61de420a21a2f1aaef93e38ecd0e45e8bc9f0a`.
2. a *type*. There are 4 types of objects:
   <<commit,commits>>, <<tree,trees>>, <<blob,blobs>>,
   and <<tag-object,tag objects>>.
3. *contents*. The structure of the contents depends on the type.

Once an object is created, it can never be changed.
Here are the 4 types of objects:

[[commit]]
commits::
    A commit contains:
+
1. Its *parent commit ID(s)*. The first commit in a repository has 0 parents,
  regular commits have 1 parent, merge commits have 2+ parents
2. A *commit message*
3. All the *files* in the commit, stored as a *<<tree,tree>>*
4. An *author* and the time the commit was authored
5. A *committer* and the time the commit was committed
+
Here's how an example commit is stored:
+
----
tree 1b61de420a21a2f1aaef93e38ecd0e45e8bc9f0a
parent 4ccb6d7b8869a86aae2e84c56523f8705b50c647
author Maya <maya@example.com> 1759173425 -0400
committer Maya <maya@example.com> 1759173425 -0400

Add README
----
+
Like all other objects, commits can never be changed after they're created.
For example, "amending" a commit with `git commit --amend` creates a new commit.
The old commit will eventually be deleted by `git gc`.

[[tree]]
trees::
    A tree is how Git represents a directory. It lists, for each item in
    the tree:
+
1. The *permissions*, for example `100644`
2. The *type*: either <<blob,`blob`>> (a file), `tree` (a directory),
  or <<commit,`commit`>> (a Git submodule)
3. The *object ID*
4. The *filename*
+
For example, this is how a tree containing one directory (`src`) and one file
(`README.md`) is stored:
+
----
100644 blob 8728a858d9d21a8c78488c8b4e70e531b659141f README.md
040000 tree 89b1d2e0495f66d6929f4ff76ff1bb07fc41947d src
----
+
*NOTE:* The permissions are in the same format as UNIX permissions, but
the only allowed permissions for files (blobs) are 644 and 755.

[[blob]]
blobs::
    A blob is how Git represents a file. A blob object contains the
    file's contents.
+
Storing a new blob for every new version of a file can get big, so
`git gc` periodically compresses objects for efficiency in `.git/objects/pack`.

[[tag-object]]
tag objects::
    Tag objects (also known as "annotated tags") contain:
+
1. The *tagger* and tag date
2. A *tag message*, similar to a commit message
3. The *ID* of the object (often a commit) that they reference

[[references]]
REFERENCES
----------

References are a way to give a name to a commit.
It's easier to remember "the changes I'm working on are on the `turtle`
branch" than "the changes are in commit bb69721404348e".
Git often uses "ref" as shorthand for "reference".

References that you create are stored in the `.git/refs` directory,
and Git has a few special internal references like `HEAD` that are stored
in the base `.git` directory.

References can either be:

1. References to an object ID, usually a <<commit,commit>> ID
2. References to another reference. This is called a "symbolic reference".

Git handles references differently based on which subdirectory of
`.git/refs` they're stored in.
Here are the main types:

[[branch]]
branches: `.git/refs/heads/<name>`::
    A branch is a name for a commit ID.
    That commit is the latest commit on the branch.
    Branches are stored in the `.git/refs/heads/` directory.
+
To get the history of commits on a branch, Git will start at the commit
ID the branch references, and then look at the commit's parent(s),
the parent's parent, etc.

[[tag]]
tags: `.git/refs/tags/<name>`::
    A tag is a name for a commit ID, tag object ID, or other object ID.
    Tags are stored in the `refs/tags/` directory.
+
Even though branches and commits are both "a name for a commit ID", Git
treats them very differently.
Branches are expected to be regularly updated as you work on the branch,
but it's expected that a tag will never change after you create it.

[[HEAD]]
HEAD: `.git/HEAD`::
    `HEAD` is where Git stores your current <<branch,branch>>.
    `HEAD` is normally a symbolic reference to your current branch, for
    example `ref: refs/heads/main` if your current branch is `main`.
    `HEAD` can also be a direct reference to a commit ID,
    that's called "detached HEAD state".

[[remote-tracking-branch]]
remote tracking branches: `.git/refs/remotes/<remote>/<branch>`::
    A remote-tracking branch is a name for a commit ID.
    It's how Git stores the last-known state of a branch in a remote
    repository. `git fetch` updates remote-tracking branches. When
    `git status` says "you're up to date with origin/main", it's looking at
    this.

[[other-refs]]
Other references::
    Git tools may create references in any subdirectory of `.git/refs`.
    For example, linkgit:git-stash[1], linkgit:git-bisect[1],
    and linkgit:git-notes[1] all create their own references
    in `.git/refs/stash`, `.git/refs/bisect`, etc.
    Third-party Git tools may also create their own references.
+
Git may also create references in the base `.git` directory
other than `HEAD`, like `ORIG_HEAD`.

*NOTE:* As an optimization, references may be stored as packed
refs instead of in `.git/refs`. See linkgit:git-pack-refs[1].

[[index]]
THE INDEX
---------

The index, also known as the "staging area", contains the current staged
version of every file in your Git repository. When you commit, the files
in the index are used as the files in the next commit.

Unlike a tree, the index is a flat list of files.
Each index entry has 4 fields:

1. The *permissions*
2. The *<<blob,blob>> ID* of the file
3. The *filename*
4. The *number*. This is normally 0, but if there's a merge conflict
   there can be multiple versions (with numbers 0, 1, 2, ..)
   of the same filename in the index.

It's extremely uncommon to look at the index directly: normally you'd
run `git status` to see a list of changes between the index and <<HEAD,HEAD>>.
But you can use `git ls-files --stage` to see the index.
Here's the output of `git ls-files --stage` in a repository with 2 files:

----
100644 8728a858d9d21a8c78488c8b4e70e531b659141f 0 README.md
100644 665c637a360874ce43bf74018768a96d2d4d219a 0 src/hello.py
----

[[reflogs]]
REFLOGS
-------

Git stores the history of branch, tag, and HEAD refs in a reflog
(you should read "reflog" as "ref log"). Not every ref is logged by
default, but any ref can be logged.

Each reflog entry has:

1. *Before/after *commit IDs*
2. *User* who made the change, for example `Maya <maya@example.com>`
3. *Timestamp*
4. *Log message*, for example `pull: Fast-forward`

Reflogs only log changes made in your local repository.
They are not shared with remotes.

GIT
---
Part of the linkgit:git[1] suite
